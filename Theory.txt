Bean
-- Это просто Java обьект
-- Когда Java обьекты создаются с помощью Springа они называются бинами (beans)
-- Бины создаются из Java классов (так же, как и обычные обьекты)


Spring модно конфигурировать с помощью:
-- XML файла конфигурации (старый способ, но многие существующие приложения до сих пор его используют)
-- Java аннотаций и немного XML (современный способ)
-- Вся конфигурации на Java коде (современный способ)


Типичные шаги в работе со Spring
-- Создаем Java - классы (будущие бины)
-- Создаем и связываем бины с помощью Spring (аннотация, XML или Java код)
-- При использовании, все обьекты (бины) берутся из контейнера Spring


Способы внедрения зависимостей
-- Через конструктор
-- Через setter
-- Есть множество конфигураций того, как внедрять (scope, factory method и т. д.)
-- Можно внедрять через XML, аннотации или Java - код
-- Процесс внедрения можно автоматизировать (Autowiring)


Что такое scope?
-- scope задает то, как Spring будет создавать ваши бины


Singleton
Scope, который используется по умолчанию
-- По умолчанию создается один обьект (он создается до вызова метода getBean())
-- При всех вызовах getBean() возвращается ссылка на один и тот же единственный обьект


Singleton
-- Scope Singleton чаще всего используется тогда, когда у нашего бина нет изменяемых состояний (stateless)
-- Потому что если будем изменять состояние у Singleton бина, столкнемся с проблемой
-- Также мы можем явно указать scope="singleton"
-- Singleton это паттерн программирования которую нужно знать


Prototype
Scope, который каждый раз создает новый обьект при вызове getBean()
-- Scope Prototype чаще всего используется тогда, когда у нашего бина есть изменяемые состояния(stateful)


Жизненный цикл бина (Bean LifeCycle)
Вы запускаете Spring приложения -> Запускается Spring контейнер ->
Создается обьект бина -> В бин внедряется зависимости (Dependency Injection) ->
Вызывается указанный init-method -> Бин готов к использованию ->
Вызывается указанный destroy-method -> Остановка Spring приложения


init-method & destroy-method

init-method
-- Метод, который запускается в ходе инициализации бина
-- Инициализация ресурсов, обращение к внешним файлам, запуск БД

destroy-method
-- Метод, который запускается в ходе уничтожения бина (при завершении приложения)
-- Очищение ресурсов, закрытие потоков ввода-вывода, закрытие доступа к БД


Тонкости init и destroy методов

Модификаторы доступа
-- У этих методов может быть любой модификатор доступа (public, protected, private)

Тип возвращаемого значения
-- Может быть любой, но чаще всего используется void (так как нет возможности получить возвращаемое значения)

Название метода
-- Название может быть любым

Аргументы метода
-- Эти методы не должны принимать на вход какие-либо аргументы

Еще одна тонкость
Для бинов со scope "prototype" Spring не вызывает destroy метод
Spring не берет на себя полный жизненный цикл бинов со scope "prototype". Spring отдает prototype бины клиенту и больше о них не заботится (в отличии от singleton бинов)


factory-method
Фабричный метод - это паттерн программирования
Вкратце: паттерн "фабричный метод" предлагает создавать обьекты не напрямую, используя оператор new, а через вызов особого фабричного метода. Обьекты все равно будут создаваться при помощи new, но делать это будет фабричный метод (иногда это бывает полезно)




Что такое Java Аннотации?
Java аннотации - это специальный тип комментариев в вашем коде с помощью которых можно:
-- Передавать каки-либо инструкции для Java компилятора (пример: @Override)
-- Передавать какие-либо инструкции для анализаторов исходного кода
-- Передавать метаданные, которые могут быть использованы либо вашим Java приложениями (с помощью рефлексии), либо другими приложениями или фреймворками (например: Spring Framework)


Зачем использовать аннотации?
-- Короче, чем XML конфигурация
-- Удобнее, чем XML конфигурация
-- Код становится более читабельным


Как работает конфигурация с помощью аннотаций?
-- Spring сканирует все ваши классы
-- Находит классы со специальными аннотациями и автоматически создает бины из этих классов


Аннотация @Component
-- Помечаем ей класс, если хотим, чтобы Spring Framework создал бин из этого класса
-- Именно эту аннотацию Spring Framework ищет, когда сканирует все ваши классы
-- Можно указать id для создаваемого бина, можно не указывать (тогда название будет название_класса_с_маленькой_буквы)


Аннотация @AutoWired
Мы больше не внедряем зависимость вручную, Spring сам ищет подходящий бин и автоматически внедряет его
-- Spring сканирует все классы с аннотацией @Component и создает бины для этих классов
-- Spring сканирует все созданные бины и проверяет, подходит ли хотя бы один бин в качестве зависимости там, где мы указали аннотацию @Autowired
-- Если находится один подходящий бин, он внедряется в качестве зависимости
-- Если не находится ни одного бина - ошибка
-- Если несколько бинов подходят - неоднозначность (будет рассмотрена на следующим уроке)

-- Аннотация @Autowired подбирает подходящие бины по их типу (класс или интерфейс)
-- Аннотация @Autowired можно использовать на полях, сеттерах, конструкторах
-- Аннотация @Autowired внедрит зависимость в приватное поле даже если нет конструктора или сеттера. Делает она это с помощью Рефлексии (Java Reflection API)


Аннотация @Qualifier
-- Указываем id того бина, который хотим внедрить
-- Аннотацию можно использовать на: Конструкторах, Сеттерах, Полях

Необычный синтаксис
Когда внедрения производится с помощью конструктора, для уточнения зависимостей необходимо использовать такой синтаксис: Аннотацию @Qualifier необходимо использовать рядом с аргументами конструктора


Аннотация @Value

Внедрение значение из внешнего файла
-- musicPlayer.properties
-- <context: property-placeholder location="classpath:musicPlayer.properties"/>
-- @Value("${musicPlayer.name}"), @Value(${musicPlayer.volume})


Аннотация @Scope

-- @Scope("singleton") (по умолчанию стоить когда не указываешь)
-- @Scope("prototype")


Аннотация @PostConstruct и @PreDestroy

-- @PostConstruct = init-method
-- @PreDestroy = destroy-method





@Configuration - для аннотаций класса конфигураций

@Beam - для аннотаций когда нужно вручную
{
@Bean
public Class beanID() {
return new Class();
}
}

Вместо ClassPathXmlApplicationContext, AnnotationConfigAppilcationContext

@PropertySource("classpath:somecalss.properties")

